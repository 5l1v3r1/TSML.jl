<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and Functions · TSML Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TSML Documentation</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">HOME</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/aggregators/">Aggregators and Imputers</a></li><li><a class="tocitem" href="../../tutorial/pipeline/">Pipeline</a></li><li><a class="tocitem" href="../../tutorial/statistics/">Statistical Metrics</a></li><li><a class="tocitem" href="../../tutorial/monotonic_plotting/">Monotonic Detection and Plotting</a></li><li><a class="tocitem" href="../../tutorial/tsclassifier/">TS Data Discovery</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/valueproc/">Value PreProcessing</a></li><li><a class="tocitem" href="../../man/dateproc/">Date PreProcessing</a></li><li><a class="tocitem" href="../../man/aggregation/">Aggregation</a></li><li><a class="tocitem" href="../../man/imputation/">Imputation</a></li></ul></li><li><span class="tocitem">ML Library</span><ul><li class="is-active"><a class="tocitem" href>Types and Functions</a><ul class="internal"><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li><li><a class="tocitem" href="#Descriptions-1"><span>Descriptions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ML Library</a></li><li class="is-active"><a href>Types and Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types and Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IBM/TSML.jl/blob/master/docs/src/lib/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="lib_decisiontree-1"><a class="docs-heading-anchor" href="#lib_decisiontree-1">Types and Functions</a><a class="docs-heading-anchor-permalink" href="#lib_decisiontree-1" title="Permalink"></a></h1><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#TSML.DecisionTreeLearners.Adaboost"><code>TSML.DecisionTreeLearners.Adaboost</code></a></li><li><a href="#TSML.DecisionTreeLearners.PrunedTree"><code>TSML.DecisionTreeLearners.PrunedTree</code></a></li><li><a href="#TSML.DecisionTreeLearners.RandomForest"><code>TSML.DecisionTreeLearners.RandomForest</code></a></li><li><a href="#TSML.Outliernicers.Outliernicer"><code>TSML.Outliernicers.Outliernicer</code></a></li><li><a href="#TSML.Plotters.Plotter"><code>TSML.Plotters.Plotter</code></a></li><li><a href="#TSML.BaselineAlgos.Baseline"><code>TSML.BaselineAlgos.Baseline</code></a></li><li><a href="#TSML.BaselineAlgos.Identity"><code>TSML.BaselineAlgos.Identity</code></a></li><li><a href="#TSML.EnsembleMethods.BestLearner"><code>TSML.EnsembleMethods.BestLearner</code></a></li><li><a href="#TSML.EnsembleMethods.StackEnsemble"><code>TSML.EnsembleMethods.StackEnsemble</code></a></li><li><a href="#TSML.EnsembleMethods.VoteEnsemble"><code>TSML.EnsembleMethods.VoteEnsemble</code></a></li><li><a href="#TSML.MLBaseWrapper.StandardScaler"><code>TSML.MLBaseWrapper.StandardScaler</code></a></li><li><a href="#TSML.MLBaseWrapper.Standardize"><code>TSML.MLBaseWrapper.Standardize</code></a></li><li><a href="#TSML.Monotonicers.Monotonicer"><code>TSML.Monotonicers.Monotonicer</code></a></li><li><a href="#TSML.Statifiers.Statifier"><code>TSML.Statifiers.Statifier</code></a></li><li><a href="#TSML.BaseFilters.Imputer"><code>TSML.BaseFilters.Imputer</code></a></li><li><a href="#TSML.BaseFilters.OneHotEncoder"><code>TSML.BaseFilters.OneHotEncoder</code></a></li><li><a href="#TSML.BaseFilters.Wrapper"><code>TSML.BaseFilters.Wrapper</code></a></li><li><a href="#TSML.BaseFilters.createtransformer"><code>TSML.BaseFilters.createtransformer</code></a></li><li><a href="#TSML.BaseFilters.find_nominal_columns-Tuple{DataFrame}"><code>TSML.BaseFilters.find_nominal_columns</code></a></li><li><a href="#TSML.ValDateFilters.BzCSVDateValReader"><code>TSML.ValDateFilters.BzCSVDateValReader</code></a></li><li><a href="#TSML.ValDateFilters.CSVDateValReader"><code>TSML.ValDateFilters.CSVDateValReader</code></a></li><li><a href="#TSML.ValDateFilters.CSVDateValWriter"><code>TSML.ValDateFilters.CSVDateValWriter</code></a></li><li><a href="#TSML.ValDateFilters.DateValLinearImputer"><code>TSML.ValDateFilters.DateValLinearImputer</code></a></li><li><a href="#TSML.ValDateFilters.DateValMultiNNer"><code>TSML.ValDateFilters.DateValMultiNNer</code></a></li><li><a href="#TSML.ValDateFilters.DateValNNer"><code>TSML.ValDateFilters.DateValNNer</code></a></li><li><a href="#TSML.ValDateFilters.DateValgator"><code>TSML.ValDateFilters.DateValgator</code></a></li><li><a href="#TSML.ValDateFilters.DateValizer"><code>TSML.ValDateFilters.DateValizer</code></a></li><li><a href="#TSML.ValDateFilters.Dateifier"><code>TSML.ValDateFilters.Dateifier</code></a></li><li><a href="#TSML.ValDateFilters.Matrifier"><code>TSML.ValDateFilters.Matrifier</code></a></li><li><a href="#TSML.TSClassifiers.TSClassifier"><code>TSML.TSClassifiers.TSClassifier</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!-Tuple{PrunedTree,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!-Tuple{StackEnsemble,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!-Tuple{RandomForest,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!-Tuple{BestLearner,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!-Tuple{Adaboost,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!-Tuple{VoteEnsemble,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!-Tuple{Transformer,DataFrame,Array{#s15,1} where #s15}"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{StandardScaler,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{PrunedTree,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{RandomForest,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{CSVDateValWriter,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{Baseline,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{DateValNNer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{DateValMultiNNer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{Transformer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{Monotonicer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{DateValgator,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{Matrifier,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{Outliernicer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{Plotter,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{DateValLinearImputer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{Adaboost,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{DateValizer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{BestLearner,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{VoteEnsemble,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{Identity,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{StackEnsemble,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li><li><a href="#TSML.TSMLTypes.transform!-Tuple{Dateifier,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a></li></ul><h2 id="Descriptions-1"><a class="docs-heading-anchor" href="#Descriptions-1">Descriptions</a><a class="docs-heading-anchor-permalink" href="#Descriptions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TSML.DecisionTreeLearners.Adaboost" href="#TSML.DecisionTreeLearners.Adaboost"><code>TSML.DecisionTreeLearners.Adaboost</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Adaboost(
  Dict(
    :output =&gt; :class,
    :num_iterations =&gt; 7
  )
)</code></pre><p>Adaboosted decision tree stumps. See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparameters:</p><ul><li><code>:num_iterations</code> =&gt; 7 (number of iterations of AdaBoost)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/decisiontree.jl#L187-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.DecisionTreeLearners.PrunedTree" href="#TSML.DecisionTreeLearners.PrunedTree"><code>TSML.DecisionTreeLearners.PrunedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrunedTree(
  Dict(
    :purity_threshold =&gt; 1.0,
    :max_depth =&gt; -1,
    :min_samples_leaf =&gt; 1,
    :min_samples_split =&gt; 2,
    :min_purity_increase =&gt; 0.0
  )
)</code></pre><p>Decision tree classifier.   See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparmeters:</p><ul><li><code>:purity_threshold</code> =&gt; 1.0 (merge leaves having &gt;=thresh combined purity)</li><li><code>:max_depth</code> =&gt; -1 (maximum depth of the decision tree)</li><li><code>:min_samples_leaf</code> =&gt; 1 (the minimum number of samples each leaf needs to have)</li><li><code>:min_samples_split</code> =&gt; 2 (the minimum number of samples in needed for a split)</li><li><code>:min_purity_increase</code> =&gt; 0.0 (minimum purity needed for a split)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/decisiontree.jl#L19-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.DecisionTreeLearners.RandomForest" href="#TSML.DecisionTreeLearners.RandomForest"><code>TSML.DecisionTreeLearners.RandomForest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RandomForest(
  Dict(
    :output =&gt; :class,
    :num_subfeatures =&gt; 0,
    :num_trees =&gt; 10,
    :partial_sampling =&gt; 0.7,
    :max_depth =&gt; -1
  )
)</code></pre><p>Random forest classification.  See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparmeters:</p><ul><li><code>:num_subfeatures</code> =&gt; 0  (number of features to consider at random per split)</li><li><code>:num_trees</code> =&gt; 10 (number of trees to train)</li><li><code>:partial_sampling</code> =&gt; 0.7 (fraction of samples to train each tree on)</li><li><code>:max_depth</code> =&gt; -1 (maximum depth of the decision trees)</li><li><code>:min_samples_leaf</code> =&gt; 1 (the minimum number of samples each leaf needs to have)</li><li><code>:min_samples_split</code> =&gt; 2 (the minimum number of samples in needed for a split)</li><li><code>:min_purity_increase</code> =&gt; 0.0 (minimum purity needed for a split)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/decisiontree.jl#L101-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!-Tuple{Adaboost,DataFrame,Array{T,1} where T}" href="#TSML.TSMLTypes.fit!-Tuple{Adaboost,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(adaboost::Adaboost, features::T, labels::Vector) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Optimize the hyperparameters of <code>Adaboost</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/decisiontree.jl#L222-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!-Tuple{PrunedTree,DataFrame,Array{T,1} where T}" href="#TSML.TSMLTypes.fit!-Tuple{PrunedTree,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(tree::PrunedTree, features::T, labels::Vector) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Optimize the hyperparameters of <code>PrunedTree</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/decisiontree.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!-Tuple{RandomForest,DataFrame,Array{T,1} where T}" href="#TSML.TSMLTypes.fit!-Tuple{RandomForest,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(forest::RandomForest, features::T, labels::Vector) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Optimize the parameters of the <code>RandomForest</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/decisiontree.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{Adaboost,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{Adaboost,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(adaboost::Adaboost, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Predict using the optimized hyperparameters of the trained <code>Adaboost</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/decisiontree.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{PrunedTree,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{PrunedTree,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(tree::PrundTree, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Predict using the optimized hyperparameters of the trained <code>PrunedTree</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/decisiontree.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{RandomForest,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{RandomForest,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(forest::RandomForest, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Predict using the optimized hyperparameters of the trained <code>RandomForest</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/decisiontree.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Outliernicers.Outliernicer" href="#TSML.Outliernicers.Outliernicer"><code>TSML.Outliernicers.Outliernicer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Outliernicer(Dict(
   :dateinterval =&gt; Dates.Hour(1),
   :nnsize =&gt; 1,
   :missdirection =&gt; :symmetric
))</code></pre><p>Detects outliers below or above (q25-iqr,q75+iqr) and calls DateValNNer to replace them with nearest neighbors.</p><p>Example:</p><pre><code class="language-none">fname = joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
csvfilter = CSVDateValReader(Dict(:filename=&gt;fname,:dateformat=&gt;&quot;dd/mm/yyyy HH:MM&quot;))
valgator = DateValgator(Dict(:dateinterval=&gt;Dates.Hour(1)))
valnner = DateValNNer(Dict(:dateinterval=&gt;Dates.Hour(1)))
stfier = Statifier(Dict(:processmissing=&gt;true))
mono = Monotonicer(Dict())
outliernicer = Outliernicer(Dict(:dateinterval=&gt;Dates.Hour(1)))

mpipeline = Pipeline(Dict(
     :transformers =&gt; [csvfilter,valgator,mono,valnner,outliernicer,stfier]
   )
)
fit!(mpipeline)
results = transform!(mpipeline)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/outliernicer.jl#L18-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(st::Outliernicer, features::T, labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Check that <code>features</code> are two-colum data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/outliernicer.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{Outliernicer,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{Outliernicer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(st::Outliernicer, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Locate outliers based on IQR factor and calls DateValNNer to replace them with nearest neighbors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/outliernicer.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Plotters.Plotter" href="#TSML.Plotters.Plotter"><code>TSML.Plotters.Plotter</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Plotter( Dict( :interactive =&gt; false, :pdfoutput =&gt; false ) )</p><p>Plots a TS by default but performs interactive plotting if specified during instance creation.</p><ul><li><code>:interactive</code> =&gt; boolean to indicate whether to use interactive plotting with <code>false</code> as default</li><li><code>:pdfoutput</code> =&gt; boolean to indicate whether ouput will be saved as pdf with <code>false</code> as default</li></ul><p>Example:</p><p>csvfilter = CSVDateValReader(Dict(:filename=&gt;fname,:dateformat=&gt;&quot;dd/mm/yyyy HH:MM&quot;)) pltr = Plotter(Dict(:interactive =&gt; false))</p><p>mpipeline = Pipeline(Dict( :transformers =&gt; [csvfilter,pltr] ) ) fit!(mpipeline) myplot = transform!(mpipeline)</p><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/plotter.jl#L31-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fit!(pltr::Plotter, features::T, labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</p><p>Check validity of <code>features</code>: 2-column Date,Val data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/plotter.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{Plotter,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{Plotter,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>transform!(pltr::Plotter, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</p><p>Convert <code>missing</code> into <code>NaN</code> to allow plotting of discontinuities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/plotter.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.BaselineAlgos.Baseline" href="#TSML.BaselineAlgos.Baseline"><code>TSML.BaselineAlgos.Baseline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Baseline(
   default_args = Dict(
      :output =&gt; :class,
      :strat =&gt; mode
   )
)</code></pre><p>Baseline model that returns the mode during classification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/baseline.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.BaselineAlgos.Identity" href="#TSML.BaselineAlgos.Identity"><code>TSML.BaselineAlgos.Identity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Identity(args=Dict())</code></pre><p>Returns the input as output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/baseline.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(idy::Identity,x::Matrix,y::Vector)</code></pre><p>Does nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/baseline.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(bsl::Baseline,x::Matrix,y::Vector)</code></pre><p>Get the mode of the training data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/baseline.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{Baseline,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{Baseline,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(bsl::Baseline,x::Matrix)</code></pre><p>Return the mode in classification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/baseline.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{Identity,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{Identity,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(idy::Identity,x::Matrix)</code></pre><p>Return the input as output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/baseline.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.EnsembleMethods.BestLearner" href="#TSML.EnsembleMethods.BestLearner"><code>TSML.EnsembleMethods.BestLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BestLearner(
   Dict(
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Function to return partitions of instance indices.
      :partition_generator =&gt; (instances, labels) -&gt; kfold(size(instances, 1), 5),
      # Function that selects the best learner by index.
      # Arg learner_partition_scores is a (learner, partition) score matrix.
      :selection_function =&gt; (learner_partition_scores) -&gt; findmax(mean(learner_partition_scores, dims=2))[2],      
      # Score type returned by score() using respective output.
      :score_type =&gt; Real,
      # Candidate learners.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()],
      # Options grid for learners, to search through by BestLearner.
      # Format is [learner_1_options, learner_2_options, ...]
      # where learner_options is same as a learner&#39;s options but
      # with a list of values instead of scalar.
      :learner_options_grid =&gt; nothing
   )
)</code></pre><p>Selects best learner from the set by performing a  grid search on learners if grid option is indicated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/ensemble.jl#L222-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.EnsembleMethods.StackEnsemble" href="#TSML.EnsembleMethods.StackEnsemble"><code>TSML.EnsembleMethods.StackEnsemble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StackEnsemble(
   Dict(    
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Set of learners that produce feature space for stacker.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()],
      # Machine learner that trains on set of learners&#39; outputs.
      :stacker =&gt; RandomForest(),
      # Proportion of training set left to train stacker itself.
      :stacker_training_proportion =&gt; 0.3,
      # Provide original features on top of learner outputs to stacker.
      :keep_original_features =&gt; false
   )
)</code></pre><p>An ensemble where a &#39;stack&#39; of learners is used for training and prediction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/ensemble.jl#L80-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.EnsembleMethods.VoteEnsemble" href="#TSML.EnsembleMethods.VoteEnsemble"><code>TSML.EnsembleMethods.VoteEnsemble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VoteEnsemble(
   Dict( 
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Learners in voting committee.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()]
   )
)</code></pre><p>Set of machine learners employing majority vote to decide prediction.</p><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/ensemble.jl#L22-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!-Tuple{BestLearner,DataFrame,Array{T,1} where T}" href="#TSML.TSMLTypes.fit!-Tuple{BestLearner,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(bls::BestLearner, instances::T, labels::Vector) where {T&lt;:Union{Matrix,DataFrame}}</code></pre><p>Training phase:</p><ul><li>obtain learners as is if grid option is not present </li><li>generate learners if grid option is present </li><li>foreach prototype learner, generate learners with specific options found in grid</li><li>generate partitions</li><li>train each learner on each partition and obtain validation output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/ensemble.jl#L276-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!-Tuple{StackEnsemble,DataFrame,Array{T,1} where T}" href="#TSML.TSMLTypes.fit!-Tuple{StackEnsemble,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(se::StackEnsemble, instances::T, labels::Vector) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Training phase of the stack of learners.</p><ul><li>perform holdout to obtain indices for </li><li>partition learner and stacker training sets</li><li>partition training set for learners and stacker</li><li>train all learners</li><li>train stacker on learners&#39; outputs</li><li>build final model from the trained learners</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/ensemble.jl#L121-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!-Tuple{VoteEnsemble,DataFrame,Array{T,1} where T}" href="#TSML.TSMLTypes.fit!-Tuple{VoteEnsemble,DataFrame,Array{T,1} where T}"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(ve::VoteEnsemble, instances::T, labels::Vector) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Training phase of the ensemble.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/ensemble.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{BestLearner,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{BestLearner,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(bls::BestLearner, instances::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Choose the best learner based on cross-validation results and use it for prediction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/ensemble.jl#L367-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{StackEnsemble,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{StackEnsemble,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(se::StackEnsemble, instances::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Build stacker instances and predict</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/ensemble.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{VoteEnsemble,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{VoteEnsemble,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(ve::VoteEnsemble, instances::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Prediction phase of the ensemble.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/ensemble.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.MLBaseWrapper.StandardScaler" href="#TSML.MLBaseWrapper.StandardScaler"><code>TSML.MLBaseWrapper.StandardScaler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StandardScaler(
   Dict( 
      :center =&gt; true,
      :scale =&gt; true
   )
)</code></pre><p>Standardizes each feature using (X - mean) / stddev. Will produce NaN if standard deviation is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/mlbase.jl#L16-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.MLBaseWrapper.Standardize" href="#TSML.MLBaseWrapper.Standardize"><code>TSML.MLBaseWrapper.Standardize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Standardize(d::Int, m::Vector{Float64}, s::Vector{Float64})</code></pre><p>Standardization type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/mlbase.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(st::StandardScaler, features::T, labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Compute the parameters to center and scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/mlbase.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{StandardScaler,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{StandardScaler,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(st::StandardScaler, features::T)  where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Apply the computed parameters for centering and scaling to new data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/mlbase.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Monotonicers.Monotonicer" href="#TSML.Monotonicers.Monotonicer"><code>TSML.Monotonicers.Monotonicer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Monotonicer()</code></pre><p>Monotonic filter to detect and normalize two types of dataset: </p><ul><li>daily monotonic </li><li>entirely non-decreasing/non-increasing data</li></ul><p>Example: </p><pre><code class="language-none">fname = joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
csvfilter = CSVDateValReader(Dict(:filename=&gt;fname,:dateformat=&gt;&quot;dd/mm/yyyy HH:MM&quot;))
valgator = DateValgator(Dict(:dateinterval=&gt;Dates.Hour(1)))
valnner = DateValNNer(Dict(:dateinterval=&gt;Dates.Hour(1)))
stfier = Statifier(Dict(:processmissing=&gt;true))
mono = Monotonicer(Dict())

mypipeline = Pipeline(Dict(
    :transformers =&gt; [csvfilter,valgator,mono,stfier]
   )
)
fit!(mypipeline)
result = transform!(mypipeline)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/monotonicer.jl#L18-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(st::Monotonicer,features::T, labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>A function that checks if <code>features</code> are two-column data of  Dates and Values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/monotonicer.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{Monotonicer,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{Monotonicer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(st::Monotonicer, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Normalize monotonic or daily monotonic data by taking the diffs and counting the flips.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/monotonicer.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.Statifiers.Statifier" href="#TSML.Statifiers.Statifier"><code>TSML.Statifiers.Statifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Statifier(Dict(
   :processmissing =&gt; true
))</code></pre><p>Outputs summary statistics such as mean, median, quartile, entropy, kurtosis, skewness, etc. with parameter: </p><ul><li><code>:processmissing</code> =&gt; <code>boolean</code> to indicate whether to include <code>missing</code> data stats.</li></ul><p>Example:</p><pre><code class="language-none">dt=[missing;rand(1:10,3);missing;missing;missing;rand(1:5,3)]
dat = DataFrame(Date= DateTime(2017,12,31,1):Dates.Hour(1):DateTime(2017,12,31,10) |&gt; collect,
                Value = dt)

statfier = Statifier(Dict(:processmissing=&gt;false))

fit!(statfier,dat)
results=transform!(statfier,dat)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/statifier.jl#L22-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(st::Statifier, features::T=[], labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Validate argument to make sure it&#39;s a 2-column format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/statifier.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!" href="#TSML.TSMLTypes.transform!"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform!(st::Statifier, features::T=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Compute statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/statifier.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.BaseFilters.Imputer" href="#TSML.BaseFilters.Imputer"><code>TSML.BaseFilters.Imputer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Imputer(
   Dict(
      # Imputation strategy.
      # Statistic that takes a vector such as mean or median.
      :strategy =&gt; mean
   )
)</code></pre><p>Imputes NaN values from Float64 features.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/basefilters.jl#L130-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.BaseFilters.OneHotEncoder" href="#TSML.BaseFilters.OneHotEncoder"><code>TSML.BaseFilters.OneHotEncoder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OneHotEncoder(Dict(
   # Nominal columns
   :nominal_columns =&gt; nothing,

   # Nominal column values map. Key is column index, value is list of
   # possible values for that column.
   :nominal_column_values_map =&gt; nothing
))</code></pre><p>Transforms instances with nominal features into one-hot form and coerces the instance matrix to be of element type Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/basefilters.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.BaseFilters.Wrapper" href="#TSML.BaseFilters.Wrapper"><code>TSML.BaseFilters.Wrapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Wrapper(
   default_args = Dict(
      # Transformer to call.
      :transformer =&gt; OneHotEncoder(),
      # Transformer args.
      :transformer_args =&gt; nothing
   )
)</code></pre><p>Wraps around a TSML transformer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/basefilters.jl#L179-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.BaseFilters.createtransformer" href="#TSML.BaseFilters.createtransformer"><code>TSML.BaseFilters.createtransformer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">createtransformer(prototype::Transformer, args=nothing)</code></pre><p>Create transformer</p><ul><li><code>prototype</code>: prototype transformer to base new transformer on</li><li><code>options</code>: additional options to override prototype&#39;s options</li></ul><p>Returns: new transformer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/basefilters.jl#L229-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.BaseFilters.find_nominal_columns-Tuple{DataFrame}" href="#TSML.BaseFilters.find_nominal_columns-Tuple{DataFrame}"><code>TSML.BaseFilters.find_nominal_columns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_nominal_columns(features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Finds all nominal columns.</p><p>Nominal columns are those that do not have Real type nor do all their elements correspond to Real.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/basefilters.jl#L111-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.BzCSVDateValReader" href="#TSML.ValDateFilters.BzCSVDateValReader"><code>TSML.ValDateFilters.BzCSVDateValReader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BzCSVDateValReader(
   Dict(
      :filename =&gt; &quot;&quot;,
      :dateformat =&gt; &quot;&quot;
   )
)</code></pre><p>Reads Bzipped csv file and parse date using the given format.</p><ul><li><code>:filename</code> =&gt; complete path including filename of csv file</li><li><code>:dateformat</code> =&gt; date format to parse</li></ul><p>Example:</p><pre><code class="language-none">inputfile =joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv.bz2&quot;)
csvreader = BzCSVDateValReader(Dict(:filename=&gt;inputfile,:dateformat=&gt;&quot;d/m/y H:M&quot;))
filter1 = DateValgator()
filter2 = DateValNNer(Dict(:nnsize=&gt;1))
mypipeline = Pipeline(Dict(
      :transformers =&gt; [csvreader,filter1,filter2]
  )
)
fit!(mypipeline)
res=transform!(mypipeline)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L701-L727">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.CSVDateValReader" href="#TSML.ValDateFilters.CSVDateValReader"><code>TSML.ValDateFilters.CSVDateValReader</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CSVDateValReader(
   Dict(
      :filename =&gt; &quot;&quot;,
      :dateformat =&gt; &quot;&quot;
   )
)</code></pre><p>Reads csv file and parse date using the given format.</p><ul><li><code>:filename</code> =&gt; complete path including filename of csv file</li><li><code>:dateformat</code> =&gt; date format to parse</li></ul><p>Example:</p><pre><code class="language-none">inputfile =joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
csvreader = CSVDateValReader(Dict(:filename=&gt;inputfile,:dateformat=&gt;&quot;d/m/y H:M&quot;))
fit!(csvreader)
df = transform!(csvreader)

# using pipeline workflow
filter1 = DateValgator()
filter2 = DateValNNer(Dict(:nnsize=&gt;1))
mypipeline = Pipeline(Dict(
      :transformers =&gt; [csvreader,filter1,filter2]
  )
)
fit!(mypipeline)
res=transform!(mypipeline)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L555-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.CSVDateValWriter" href="#TSML.ValDateFilters.CSVDateValWriter"><code>TSML.ValDateFilters.CSVDateValWriter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CSVDateValWriter(
   Dict(
      :filename =&gt; &quot;&quot;,
      :dateformat =&gt; &quot;&quot;
   )
)</code></pre><p>Writes the time series dataframe into a file with the given date format.</p><p>Example:</p><pre><code class="language-none">inputfile =joinpath(dirname(pathof(TSML)),&quot;../data/testdata.csv&quot;)
outputfile = joinpath(&quot;/tmp/test.csv&quot;)
csvreader = CSVDateValReader(Dict(:filename=&gt;inputfile,:dateformat=&gt;&quot;d/m/y H:M&quot;))
csvwtr = CSVDateValWriter(Dict(:filename=&gt;outputfile,:dateformat=&gt;&quot;d/m/y H:M&quot;))
filter1 = DateValgator()
filter2 = DateValNNer(Dict(:nnsize=&gt;1))
mypipeline = Pipeline(Dict(
      :transformers =&gt; [csvreader,filter1,filter2,csvwtr]
  )
)
fit!(mypipeline)
res=transform!(mypipeline)

# read back what was written to validate
csvreader = CSVDateValReader(Dict(:filename=&gt;outputfile,:dateformat=&gt;&quot;y-m-d HH:MM:SS&quot;))
fit!(csvreader)
transform!(csvreader)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L628-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValLinearImputer" href="#TSML.ValDateFilters.DateValLinearImputer"><code>TSML.ValDateFilters.DateValLinearImputer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateValLinearImputer(
   Dict(
      :dateinterval =&gt; Dates.Hour(1),
  )
)</code></pre><p>Fills <code>missings</code> by linear interpolation.</p><ul><li><code>:dateinterval</code> =&gt; time period to use for grouping,</li></ul><p>Example:</p><pre><code class="language-none">Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dnnr = DateValLinearImputer()
fit!(dnnr,X)
transform!(dnnr,X)</code></pre><p>Implements: <code>fit!</code>, transform!`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L912-L939">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValMultiNNer" href="#TSML.ValDateFilters.DateValMultiNNer"><code>TSML.ValDateFilters.DateValMultiNNer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateValMultiNNer(
   Dict(
      :type =&gt; :knn # :linear
      :missdirection =&gt; :symmetric, #:reverse, # or :forward or :symmetric
      :dateinterval =&gt; Dates.Hour(1),
      :nnsize =&gt; 1,
      :strict =&gt; true,
      :aggregator =&gt; :median
  )
)</code></pre><p>Fills <code>missings</code> with their nearest-neighbors. It assumes that first column is a Date class and the other columns are Union{Missings,Real}. It uses DateValNNer and DateValizer+Impute to process each numeric column concatendate with the Date column.</p><ul><li><code>:type</code> =&gt; type of imputation which can be a linear interpolation or nearest neighbor</li><li><code>:missdirection</code> =&gt; direction to fill missing data (:symmetric, :reverse, :forward) </li><li><code>:dateinterval</code> =&gt; time period to use for grouping,</li><li><code>:nnsize</code> =&gt; neighborhood size,</li><li><code>:strict</code> =&gt; boolean value to indicate whether to be strict about replacement or not,</li><li>`:aggregator =&gt; function to aggregate based on date interval</li></ul><p>Example:</p><pre><code class="language-none">Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval1 = Array{Union{Missing,Float64}}(rand(length(gdate)))
gval2 = Array{Union{Missing,Float64}}(rand(length(gdate)))
gval3 = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing1 = Random.shuffle(1:length(gdate))[1:gmissing]
gndxmissing2 = Random.shuffle(1:length(gdate))[1:gmissing]
gndxmissing3 = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Temperature=gval1,Humidity=gval2,Ozone=gval3)
X.Temperature[gndxmissing1] .= missing
X.Humidity[gndxmissing2] .= missing
X.Ozone[gndxmissing3] .= missing

dnnr = DateValMultiNNer(Dict(
      :type=&gt;:linear,
      :dateinterval=&gt;Dates.Hour(1),
      :nnsize=&gt;10,
      :missdirection =&gt; :symmetric,
      :strict=&gt;true,
      :aggregator =&gt; :mean))
fit!(dnnr,X)
transform!(dnnr,X)</code></pre><p>Implements: <code>fit!</code>, transform!`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L769-L820">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValNNer" href="#TSML.ValDateFilters.DateValNNer"><code>TSML.ValDateFilters.DateValNNer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateValNNer(
   Dict(
      :missdirection =&gt; :symmetric, #:reverse, # or :forward or :symmetric
      :dateinterval =&gt; Dates.Hour(1),
      :nnsize =&gt; 1,
      :strict =&gt; true,
      :aggregator =&gt; :median
  )
)</code></pre><p>Fills <code>missings</code> with their nearest-neighbors.</p><ul><li><code>:missdirection</code> =&gt; direction to fill missing data (:symmetric, :reverse, :forward) </li><li><code>:dateinterval</code> =&gt; time period to use for grouping,</li><li><code>:nnsize</code> =&gt; neighborhood size,</li><li><code>:strict</code> =&gt; boolean value to indicate whether to be strict about replacement or not,</li><li>`:aggregator =&gt; function to aggregate based on date interval</li></ul><p>Example:</p><pre><code class="language-none">Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dnnr = DateValNNer(Dict(
      :dateinterval=&gt;Dates.Hour(1),
      :nnsize=&gt;10,
      :missdirection =&gt; :symmetric,
      :strict=&gt;true,
      :aggregator =&gt; :mean))
fit!(dnnr,X)
transform!(dnnr,X)</code></pre><p>Implements: <code>fit!</code>, transform!`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L413-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValgator" href="#TSML.ValDateFilters.DateValgator"><code>TSML.ValDateFilters.DateValgator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateValgator(args=Dict())
   Dict(
    :dateinterval =&gt; Dates.Hour(1),
    :aggregator =&gt; :median
  )
)</code></pre><p>Aggregates values based on date period specified.</p><p>Example:</p><pre><code class="language-none"># generate random values with missing data
Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dtvlmean = DateValgator(Dict(
      :dateinterval=&gt;Dates.Hour(1),
      :aggregator =&gt; :mean))
fit!(dtvlmean,X)
res = transform!(dtvlmean,X)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L198-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.DateValizer" href="#TSML.ValDateFilters.DateValizer"><code>TSML.ValDateFilters.DateValizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DateValizer(
   Dict(
    :medians =&gt; DataFrame(),
    :dateinterval =&gt; Dates.Hour(1)
  )
)</code></pre><p>Normalizes and cleans time series by replacing <code>missings</code> with global medians  computed based on time period groupings.</p><p>Example:</p><pre><code class="language-none"># generate random values with missing data
Random.seed!(123)
gdate = DateTime(2014,1,1):Dates.Minute(15):DateTime(2016,1,1)
gval = Array{Union{Missing,Float64}}(rand(length(gdate)))
gmissing = 50000
gndxmissing = Random.shuffle(1:length(gdate))[1:gmissing]
X = DataFrame(Date=gdate,Value=gval)
X.Value[gndxmissing] .= missing

dvzr = DateValizer(Dict(:dateinterval=&gt;Dates.Hour(1)))
fit!(dvzr,X)
transform!(dvzr,X)</code></pre><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L289-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Dateifier" href="#TSML.ValDateFilters.Dateifier"><code>TSML.ValDateFilters.Dateifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dateifier(args=Dict())
   Dict(
    :ahead =&gt; 1,
    :size =&gt; 7,
    :stride =&gt; 1
   )
)</code></pre><p>Converts a 1-D date series into sliding window matrix for ML training</p><p>Example: </p><pre><code class="language-none">dtr = Dateifier(Dict())
lower = DateTime(2017,1,1)
upper = DateTime(2018,1,31)
dat=lower:Dates.Day(1):upper |&gt; collect
vals = rand(length(dat))
x=DataFrame(Date=dat,Value=vals)
fit!(dtr,x)
res = transform!(dtr,x)</code></pre><p>Implements: <code>&#39;fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L122-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.ValDateFilters.Matrifier" href="#TSML.ValDateFilters.Matrifier"><code>TSML.ValDateFilters.Matrifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Matrifier(Dict(
   Dict(
    :ahead =&gt; 1,
    :size =&gt; 7,
    :stride =&gt; 1,
  )
)</code></pre><p>Converts a 1-D timeseries into sliding window matrix for ML training:</p><ul><li><code>:ahead</code> =&gt; steps ahead to predict</li><li><code>:size</code> =&gt; size of sliding window</li><li><code>:stride</code> =&gt; amount of overlap in sliding window</li></ul><p>Example:</p><pre><code class="language-none">mtr = Matrifier(Dict(:ahead=&gt;24,:size=&gt;24,:stride=&gt;5))
lower = DateTime(2017,1,1)
upper = DateTime(2017,1,5)
dat=lower:Dates.Hour(1):upper |&gt; collect
vals = 1:length(dat)
x = DataFrame(Date=dat,Value=vals)
fit!(mtr,x)
res = transform!(mtr,x)</code></pre><p>Implements: <code>fit!</code>, <code>transform</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L32-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dnnr::DateValMultiNNer,xx::T,y::Vector=[]) where {T&lt;:DataFrame}</code></pre><p>Validates and checks arguments for errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L844-L848">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(csvwtr::CSVDateValWriter,x::T=[],y::Vector=[]) where {T&lt;:Union{DataFrame,Vector,Matrix}}</code></pre><p>Makes sure filename and dateformat are not empty strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L672-L676">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dvmr::DateValgator,xx::T,y::Vector=[]) where {T&lt;:Union{Matrix,DataFrame}}</code></pre><p>Checks and validates arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dvzr::DateValizer,xx::T,y::Vector=[]) where {T&lt;:DataFrame}</code></pre><p>Validates input and computes global medians grouped by time period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L363-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dnnr::DateValNNer,xx::T,y::Vector=[]) where {T&lt;:DataFrame}</code></pre><p>Validates and checks arguments for errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L470-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(csvrdr::CSVDateValReader,x::T=[],y::Vector=[]) where {T&lt;:Union{DataFrame,Vector,Matrix}}</code></pre><p>Makes sure filename and dateformat are not empty strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L599-L603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(bzcsvrdr::BzCSVDateValReader,x::T=[],y::Vector=[]) where {T&lt;:Union{DataFrame,Vector,Matrix}}</code></pre><p>Makes sure filename and dateformat are not empty strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L740-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(mtr::Matrifier,xx::T,y::Vector=Vector()) where {T&lt;:Union{Matrix,Vector,DataFrame}}</code></pre><p>Checks and validate inputs are in correct structure</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dnnr::DateValLinearImputer,xx::T,y::Vector=[]) where {T&lt;:DataFrame}</code></pre><p>Validates and checks arguments for errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L953-L957">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(dtr::Dateifier,xx::T,y::Vector=[]) where {T&lt;:Union{Matrix,Vector,DataFrame}}</code></pre><p>Computes range of dates to be used during transform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!" href="#TSML.TSMLTypes.transform!"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform!(bzcsvrdr::BzCSVDateValReader,x::T=[]) where {T&lt;:Union{DataFrame,Vector,Matrix}}</code></pre><p>Uses CodecBzip2 package to read the csv file and converts it to dataframe.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L752-L756">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!" href="#TSML.TSMLTypes.transform!"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform!(csvrdr::CSVDateValReader,x::T=[]) where {T&lt;:Union{DataFrame,Vector,Matrix}}</code></pre><p>Uses CSV package to read the csv file and converts it to dataframe.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L611-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{CSVDateValWriter,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{CSVDateValWriter,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(csvwtr::CSVDateValWriter,x::T) where {T&lt;:Union{DataFrame,Vector,Matrix}}</code></pre><p>Uses CSV package to write the dataframe into a csv file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L684-L688">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{DateValLinearImputer,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{DateValLinearImputer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dnnr::DateValLinearImputer,xx::T) where {T&lt;:DataFrame}</code></pre><p>Replaces <code>missings</code> by linear interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L964-L968">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{DateValMultiNNer,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{DateValMultiNNer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dnnr::DateValMultiNNer,xx::T) where {T&lt;:DataFrame}</code></pre><p>Replaces <code>missings</code> by nearest neighbor or linear interpolation by looping over the dataset  for each column until all missing values are gone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L860-L865">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{DateValNNer,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{DateValNNer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dnnr::DateValNNer,xx::T) where {T&lt;:DataFrame}</code></pre><p>Replaces <code>missings</code> by nearest neighbor looping over the dataset until all missing values are gone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L483-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{DateValgator,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{DateValgator,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dvmr::DateValgator,xx::T) where {T&lt;:DataFrame}</code></pre><p>Aggregates values grouped by date-time period using aggregate  function such as mean, median, maximum, minimum. Default is mean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L260-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{DateValizer,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{DateValizer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dvzr::DateValizer,xx::T) where {T&lt;:DataFrame}</code></pre><p>Replaces <code>missing</code> with the corresponding global medians with respect to time period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L380-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{Dateifier,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{Dateifier,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(dtr::Dateifier,xx::T) where {T&lt;:Union{Matrix,Vector,DataFrame}}</code></pre><p>Transforms to day of the month, day of the week, etc</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{Matrifier,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{Matrifier,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(mtr::Matrifier,xx::T) where {T&lt;:Union{Matrix,Vector,DataFrame}}</code></pre><p>Applies the parameters of sliding windows to create the corresponding matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/valdatefilters.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSClassifiers.TSClassifier" href="#TSML.TSClassifiers.TSClassifier"><code>TSML.TSClassifiers.TSClassifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TSClassifier(
   Dict(
      # training directory
      :trdirectory =&gt; &quot;&quot;,
      :tstdirectory =&gt; &quot;&quot;,
      :modeldirectory =&gt; &quot;&quot;,
      :feature_range =&gt; 7:20,
      :juliarfmodelname =&gt; &quot;juliarfmodel.serialized&quot;,
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Options specific to this implementation.
      :impl_args =&gt; Dict(
         # Merge leaves having &gt;= purity_threshold CombineMLd purity.
         :purity_threshold =&gt; 1.0,
         # Maximum depth of the decision tree (default: no maximum).
         :max_depth =&gt; -1,
         # Minimum number of samples each leaf needs to have.
         :min_samples_leaf =&gt; 1,
         # Minimum number of samples in needed for a split.
         :min_samples_split =&gt; 2,
         # Minimum purity needed for a split.
         :min_purity_increase =&gt; 0.0
      )
   )
)</code></pre><p>Given a bunch of time-series with specific types. Get the statistical features of each, use these as inputs to RF classifier with output as the TS type, train and test. Another option is to use these stat features for clustering and check cluster quality. If accuracy is poor, add more stat features and repeat same process as outlined for training and testing. Assume that each time-series is named based on their type which will be used as target output. For example, temperature time series will be named as temperature?.csv where ? is an integer. Loop over each file in a directory, get stat and  record in a dictionary/dataframe, train/test. Default to using RandomForest  for classification of data types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/tsclassifier.jl#L22-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!" href="#TSML.TSMLTypes.fit!"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit!(tsc::TSClassifier, features::T=[], labels::Vector=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Get the stats of each file, collect as dataframe, and train.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/tsclassifier.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!" href="#TSML.TSMLTypes.transform!"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transform!(tsc::TSClassifier, features::T=[]) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Apply the learned parameters to the new data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/tsclassifier.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.fit!-Tuple{Transformer,DataFrame,Array{#s15,1} where #s15}" href="#TSML.TSMLTypes.fit!-Tuple{Transformer,DataFrame,Array{#s15,1} where #s15}"><code>TSML.TSMLTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(tr::Transformer, instances::T, labels::Vector) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Generic <code>fit!</code> function to be redefined using multidispatch in  different subtypes of <code>Transformer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/types.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TSML.TSMLTypes.transform!-Tuple{Transformer,DataFrame}" href="#TSML.TSMLTypes.transform!-Tuple{Transformer,DataFrame}"><code>TSML.TSMLTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(tr::Transformer, instances::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Generic <code>transform!</code> function to be redefined using multidispatch in  different subtypes of <code>Transformer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/TSML.jl/blob/2746473e9c1f5c22277f42228eaace465226029c/src/types.jl#L21-L25">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/imputation/">« Imputation</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 3 March 2020 15:35">Tuesday 3 March 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
