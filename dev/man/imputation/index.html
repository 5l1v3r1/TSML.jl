<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Imputation · TSML Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TSML Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">HOME</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/aggregators/">Aggregators and Imputers</a></li><li><a class="toctext" href="../../tutorial/pipeline/">Pipeline</a></li><li><a class="toctext" href="../../tutorial/statistics/">Statistical Metrics</a></li><li><a class="toctext" href="../../tutorial/monotonic_plotting/">Monotonic Detection and Plotting</a></li><li><a class="toctext" href="../../tutorial/tsclassifier/">TS Data Discovery</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../valueproc/">Value PreProcessing</a></li><li><a class="toctext" href="../dateproc/">Date PreProcessing</a></li><li><a class="toctext" href="../aggregation/">Aggregation</a></li><li class="current"><a class="toctext" href>Imputation</a><ul class="internal"><li><a class="toctext" href="#DateValNNer-1">DateValNNer</a></li><li><a class="toctext" href="#DateValizer-1">DateValizer</a></li></ul></li></ul></li><li><span class="toctext">ML Library</span><ul><li><a class="toctext" href="../../lib/decisiontree/">Decision Tree</a></li><li><a class="toctext" href="../../lib/functions/">Types and Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Imputation</a></li></ul><a class="edit-page" href="https://github.com/IBM/TSML.jl/blob/master/docs/src/man/imputation.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Imputation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Imputation-1" href="#Imputation-1">Imputation</a></h1><p>There are two ways to impute the <code>date,value</code> TS data. One uses <code>DateValNNer</code> which uses nearest neighbor and <code>DateValizer</code> which uses the dictionary of medians mapped to  certain date-time interval grouping.</p><h2><a class="nav-anchor" id="DateValNNer-1" href="#DateValNNer-1">DateValNNer</a></h2><p><code>DateValNNer</code> expects the following arguments with their default values during instantation: </p><ul><li><code>:dateinterval =&gt; Dates.Hour(1)</code>  <ul><li>grouping interval</li></ul></li><li><code>:nnsize =&gt; 1</code> <ul><li>size of neighborhood</li></ul></li><li><code>:missdirection =&gt; :symmetric</code> <ul><li><code>:forward</code> vs <code>:backward</code> vs <code>:symmetric</code></li></ul></li><li><code>:strict =&gt; true</code> <ul><li>whether or not to repeatedly iterate until no more missing data</li></ul></li></ul><p>The <code>:missdirection</code> indicates the imputation direction and the extent of neighborhood. Symmetric implies getting info from both sides of the missing data. <code>:forward</code> direction starts imputing from the top while the <code>:reverse</code> starts from the bottom. Please refer to  <a href="../../tutorial/aggregators/#aggregators_imputers-1">Aggregators and Imputers</a> for other examples.</p><div></div><p>Let&#39;s use the same dataset we have used in the tutorial and print the first few rows.</p><pre><code class="language-julia-repl">julia&gt; first(X,10)
10×2 DataFrame
│ Row │ Date                │ Value     │
│     │ DateTime            │ Float64⍰  │
├─────┼─────────────────────┼───────────┤
│ 1   │ 2014-01-01T00:00:00 │ missing   │
│ 2   │ 2014-01-01T00:15:00 │ missing   │
│ 3   │ 2014-01-01T00:30:00 │ missing   │
│ 4   │ 2014-01-01T00:45:00 │ missing   │
│ 5   │ 2014-01-01T01:00:00 │ missing   │
│ 6   │ 2014-01-01T01:15:00 │ missing   │
│ 7   │ 2014-01-01T01:30:00 │ missing   │
│ 8   │ 2014-01-01T01:45:00 │ 0.0521332 │
│ 9   │ 2014-01-01T02:00:00 │ 0.26864   │
│ 10  │ 2014-01-01T02:15:00 │ 0.108871  │</code></pre><p>Let&#39;s try the following setup grouping daily with <code>forward</code> imputation and 10 neighbors:</p><pre><code class="language-julia">dnnr = DateValNNer(Dict(:dateinterval=&gt;Dates.Hour(2),
             :nnsize=&gt;10,:missdirection =&gt; :forward,
             :strict=&gt;false))
fit!(dnnr,X)
forwardres=transform!(dnnr,X)</code></pre><pre><code class="language-julia-repl">julia&gt; first(forwardres,5)
5×2 DataFrame
│ Row │ Date                │ Value    │
│     │ DateTime            │ Float64⍰ │
├─────┼─────────────────────┼──────────┤
│ 1   │ 2014-01-01T00:00:00 │ 0.491286 │
│ 2   │ 2014-01-01T02:00:00 │ 0.108871 │
│ 3   │ 2014-01-01T04:00:00 │ 0.361194 │
│ 4   │ 2014-01-01T06:00:00 │ 0.918165 │
│ 5   │ 2014-01-01T08:00:00 │ 0.690462 │</code></pre><p>Same parameters as above but uses <code>reverse</code> instead of <code>forward</code> direction:</p><pre><code class="language-julia">dnnr = DateValNNer(Dict(:dateinterval=&gt;Dates.Hour(2),
             :nnsize=&gt;10,:missdirection =&gt; :reverse,
             :strict=&gt;false))
fit!(dnnr,X)
reverseres=transform!(dnnr,X)</code></pre><pre><code class="language-julia-repl">julia&gt; first(reverseres,5)
5×2 DataFrame
│ Row │ Date                │ Value    │
│     │ DateTime            │ Float64⍰ │
├─────┼─────────────────────┼──────────┤
│ 1   │ 2014-01-01T00:00:00 │ 0.491286 │
│ 2   │ 2014-01-01T02:00:00 │ 0.108871 │
│ 3   │ 2014-01-01T04:00:00 │ 0.361194 │
│ 4   │ 2014-01-01T06:00:00 │ 0.918165 │
│ 5   │ 2014-01-01T08:00:00 │ 0.690462 │</code></pre><p>Using <code>symmetric</code> imputation:</p><pre><code class="language-julia">dnnr = DateValNNer(Dict(:dateinterval=&gt;Dates.Hour(2),
             :nnsize=&gt;10,:missdirection =&gt; :symmetric,
             :strict=&gt;false))
fit!(dnnr,X)
symmetricres=transform!(dnnr,X)</code></pre><pre><code class="language-julia-repl">julia&gt; first(symmetricres,5)
5×2 DataFrame
│ Row │ Date                │ Value    │
│     │ DateTime            │ Float64⍰ │
├─────┼─────────────────────┼──────────┤
│ 1   │ 2014-01-01T00:00:00 │ 0.491286 │
│ 2   │ 2014-01-01T02:00:00 │ 0.108871 │
│ 3   │ 2014-01-01T04:00:00 │ 0.361194 │
│ 4   │ 2014-01-01T06:00:00 │ 0.918165 │
│ 5   │ 2014-01-01T08:00:00 │ 0.690462 │</code></pre><p>Unlike <code>symmetric</code> imputation that guarantees 100% imputation of missing data as long as the input has non-missing elements, <code>forward</code> and <code>reverse</code> cannot guarantee that the imputation replaces all missing data because of the boundary issues. If the top or bottom of the input is missing, the assymetric imputation will not be able to replace the endpoints that are missing. It is advised that to have successful imputation, <code>symmetric</code> imputation shall be used.</p><p>In the example above, the number of remaining missing data not imputed for <code>forward</code>, <code>reverse</code>, and <code>symmetric</code> is:</p><pre><code class="language-julia-repl">julia&gt; sum(ismissing.(forwardres[:Value]))
┌ Warning: `getindex(df::DataFrame, col_ind::ColumnIndex)` is deprecated, use `df[!, col_ind]` instead.
│   caller = top-level scope at none:0
└ @ Core none:0
3

julia&gt; sum(ismissing.(reverseres[:Value]))
┌ Warning: `getindex(df::DataFrame, col_ind::ColumnIndex)` is deprecated, use `df[!, col_ind]` instead.
│   caller = top-level scope at none:0
└ @ Core none:0
3

julia&gt; sum(ismissing.(symmetricres[:Value]))
┌ Warning: `getindex(df::DataFrame, col_ind::ColumnIndex)` is deprecated, use `df[!, col_ind]` instead.
│   caller = top-level scope at none:0
└ @ Core none:0
0</code></pre><h2><a class="nav-anchor" id="DateValizer-1" href="#DateValizer-1">DateValizer</a></h2><p><code>DateValizer</code> operates on the principle that there is a reqularity of patterns in a specific time period such that replacing values is just a matter of  extracting which time period it belongs and used the pooled median in that time period to replace the missing data. The default time period for <code>DateValizer</code> is hourly. In a more advanced implementation, we can add daily, hourly, and weekly  periods but it will require much larger hash table. Additional grouping criteria  can result into smaller subgroups which may contain 100% missing in some of these subgroups resulting to imputation failure. <code>DateValizer</code> only depends on the <code>:dateinterval =&gt; Dates.Hour(1)</code>  argument with default value of hourly. Please refer to <a href="../../tutorial/aggregators/#aggregators_imputers-1">Aggregators and Imputers</a> for more examples.</p><p>Let&#39;s try hourly, daily, and monthly median as the basis of imputation:</p><pre><code class="language-julia-repl">julia&gt; hourlyzer = DateValizer(Dict(:dateinterval =&gt; Dates.Hour(1)))
DateValizer(nothing, Dict{Symbol,Any}(:medians=&gt;0×0 DataFrame
,:dateinterval=&gt;1 hour))

julia&gt; monthlyzer = DateValizer(Dict(:dateinterval =&gt; Dates.Month(1)))
DateValizer(nothing, Dict{Symbol,Any}(:medians=&gt;0×0 DataFrame
,:dateinterval=&gt;1 month))

julia&gt; dailyzer = DateValizer(Dict(:dateinterval =&gt; Dates.Day(1)))
DateValizer(nothing, Dict{Symbol,Any}(:medians=&gt;0×0 DataFrame
,:dateinterval=&gt;1 day))

julia&gt; fit!(hourlyzer,X)
Dict{Symbol,Any} with 2 entries:
  :medians      =&gt; 24×2 DataFrame…
  :dateinterval =&gt; 1 hour

julia&gt; hourlyres = transform!(hourlyzer,X)
17521×2 DataFrame
│ Row   │ Date                │ Value    │
│       │ DateTime            │ Float64⍰ │
├───────┼─────────────────────┼──────────┤
│ 1     │ 2014-01-01T00:00:00 │ 0.498827 │
│ 2     │ 2014-01-01T01:00:00 │ 0.500748 │
│ 3     │ 2014-01-01T02:00:00 │ 0.108871 │
│ 4     │ 2014-01-01T03:00:00 │ 0.473017 │
│ 5     │ 2014-01-01T04:00:00 │ 0.361194 │
│ 6     │ 2014-01-01T05:00:00 │ 0.582318 │
│ 7     │ 2014-01-01T06:00:00 │ 0.918165 │
⋮
│ 17514 │ 2015-12-31T17:00:00 │ 0.549606 │
│ 17515 │ 2015-12-31T18:00:00 │ 0.680491 │
│ 17516 │ 2015-12-31T19:00:00 │ 0.500731 │
│ 17517 │ 2015-12-31T20:00:00 │ 0.468921 │
│ 17518 │ 2015-12-31T21:00:00 │ 0.28438  │
│ 17519 │ 2015-12-31T22:00:00 │ 0.533108 │
│ 17520 │ 2015-12-31T23:00:00 │ 0.308998 │
│ 17521 │ 2016-01-01T00:00:00 │ 0.498827 │

julia&gt; fit!(dailyzer,X)
Dict{Symbol,Any} with 2 entries:
  :medians      =&gt; 31×2 DataFrame…
  :dateinterval =&gt; 1 day

julia&gt; dailyres = transform!(dailyzer,X)
731×2 DataFrame
│ Row │ Date                │ Value    │
│     │ DateTime            │ Float64⍰ │
├─────┼─────────────────────┼──────────┤
│ 1   │ 2014-01-01T00:00:00 │ 0.48     │
│ 2   │ 2014-01-02T00:00:00 │ 0.628368 │
│ 3   │ 2014-01-03T00:00:00 │ 0.509263 │
│ 4   │ 2014-01-04T00:00:00 │ 0.559623 │
│ 5   │ 2014-01-05T00:00:00 │ 0.539073 │
│ 6   │ 2014-01-06T00:00:00 │ 0.387866 │
│ 7   │ 2014-01-07T00:00:00 │ 0.464466 │
⋮
│ 724 │ 2015-12-25T00:00:00 │ 0.44458  │
│ 725 │ 2015-12-26T00:00:00 │ 0.625784 │
│ 726 │ 2015-12-27T00:00:00 │ 0.659934 │
│ 727 │ 2015-12-28T00:00:00 │ 0.368161 │
│ 728 │ 2015-12-29T00:00:00 │ 0.506546 │
│ 729 │ 2015-12-30T00:00:00 │ 0.516895 │
│ 730 │ 2015-12-31T00:00:00 │ 0.299126 │
│ 731 │ 2016-01-01T00:00:00 │ 0.434787 │

julia&gt; fit!(monthlyzer,X)
Dict{Symbol,Any} with 2 entries:
  :medians      =&gt; 12×2 DataFrame…
  :dateinterval =&gt; 1 month

julia&gt; monthlyres = transform!(monthlyzer,X)
25×2 DataFrame
│ Row │ Date                │ Value    │
│     │ DateTime            │ Float64⍰ │
├─────┼─────────────────────┼──────────┤
│ 1   │ 2014-01-01T00:00:00 │ 0.525587 │
│ 2   │ 2014-02-01T00:00:00 │ 0.501297 │
│ 3   │ 2014-03-01T00:00:00 │ 0.540474 │
│ 4   │ 2014-04-01T00:00:00 │ 0.492871 │
│ 5   │ 2014-05-01T00:00:00 │ 0.514414 │
│ 6   │ 2014-06-01T00:00:00 │ 0.515317 │
│ 7   │ 2014-07-01T00:00:00 │ 0.501932 │
⋮
│ 18  │ 2015-06-01T00:00:00 │ 0.499711 │
│ 19  │ 2015-07-01T00:00:00 │ 0.509305 │
│ 20  │ 2015-08-01T00:00:00 │ 0.505218 │
│ 21  │ 2015-09-01T00:00:00 │ 0.511359 │
│ 22  │ 2015-10-01T00:00:00 │ 0.504835 │
│ 23  │ 2015-11-01T00:00:00 │ 0.487876 │
│ 24  │ 2015-12-01T00:00:00 │ 0.512668 │
│ 25  │ 2016-01-01T00:00:00 │ 0.482073 │</code></pre><footer><hr/><a class="previous" href="../aggregation/"><span class="direction">Previous</span><span class="title">Aggregation</span></a><a class="next" href="../../lib/decisiontree/"><span class="direction">Next</span><span class="title">Decision Tree</span></a></footer></article></body></html>
