<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Value PreProcessing · TSML Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TSML Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">HOME</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/aggregators/">Aggregators and Imputers</a></li><li><a class="toctext" href="../../tutorial/pipeline/">Pipeline</a></li><li><a class="toctext" href="../../tutorial/statistics/">Statistical Metrics</a></li><li><a class="toctext" href="../../tutorial/monotonic_plotting/">Monotonic Detection and Plotting</a></li><li><a class="toctext" href="../../tutorial/tsclassifier/">TS Data Discovery</a></li></ul></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href>Value PreProcessing</a><ul class="internal"><li><a class="toctext" href="#Matrifier-1">Matrifier</a></li></ul></li><li><a class="toctext" href="../dateproc/">Date PreProcessing</a></li><li><a class="toctext" href="../aggregation/">Aggregation</a></li><li><a class="toctext" href="../imputation/">Imputation</a></li></ul></li><li><span class="toctext">ML Library</span><ul><li><a class="toctext" href="../../lib/decisiontree/">Decision Tree</a></li><li><a class="toctext" href="../../lib/functions/">Types and Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Value PreProcessing</a></li></ul><a class="edit-page" href="https://github.com/IBM/TSML.jl/blob/master/docs/src/man/valueproc.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Value PreProcessing</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="valueprep-1" href="#valueprep-1">Value Preprocessing</a></h1><p>In order to process 1-D TS as input for ML model, it has to be converted into Matrix form where each row represents a  slice of 1-D TS representing daily/hourly/weekly pattern depending on the size of the chunk, stride, and  number of steps ahead for prediction. Below illustrates the processing workflow to <code>Matrify</code> a 1-D TS.</p><p>For illustration purposes, the code below generates a  Date,Value dataframe where the values are just a sequece of integer from 1 to the length of the date sequence. We use this simple sequence to have a better understanding how the slicing of rows, steps ahead, and the stride to create the <code>Matrified</code> output is generated.</p><pre><code class="language-julia">using Dates
using TSML, TSML.Utils, TSML.TSMLTypes
using TSML.TSMLTransformers
using DataFrames

lower = DateTime(2017,1,1)
upper = DateTime(2017,1,5)
dat=lower:Dates.Hour(1):upper |&gt; collect
vals = 1:length(dat)
x = DataFrame(Date=dat,Value=vals)</code></pre><pre><code class="language-julia-repl">julia&gt; last(x,5)
5×2 DataFrames.DataFrame
│ Row │ Date                │ Value │
│     │ Dates.DateTime      │ Int64 │
├─────┼─────────────────────┼───────┤
│ 1   │ 2017-01-04T20:00:00 │ 93    │
│ 2   │ 2017-01-04T21:00:00 │ 94    │
│ 3   │ 2017-01-04T22:00:00 │ 95    │
│ 4   │ 2017-01-04T23:00:00 │ 96    │
│ 5   │ 2017-01-05T00:00:00 │ 97    │</code></pre><h2><a class="nav-anchor" id="Matrifier-1" href="#Matrifier-1">Matrifier</a></h2><p>Let us create an instance of Matrifier passing the size of row, stride, and steps ahead to predict:</p><pre><code class="language-julia">mtr = Matrifier(Dict(:ahead=&gt;6,:size=&gt;6,:stride=&gt;3))
fit!(mtr,x)
res = transform!(mtr,x)</code></pre><pre><code class="language-julia-repl">julia&gt; first(res,5)
5×7 DataFrames.DataFrame
│ Row │ x1    │ x2    │ x3    │ x4    │ x5    │ x6    │ output │
│     │ Int64 │ Int64 │ Int64 │ Int64 │ Int64 │ Int64 │ Int64  │
├─────┼───────┼───────┼───────┼───────┼───────┼───────┼────────┤
│ 1   │ 86    │ 87    │ 88    │ 89    │ 90    │ 91    │ 97     │
│ 2   │ 83    │ 84    │ 85    │ 86    │ 87    │ 88    │ 94     │
│ 3   │ 80    │ 81    │ 82    │ 83    │ 84    │ 85    │ 91     │
│ 4   │ 77    │ 78    │ 79    │ 80    │ 81    │ 82    │ 88     │
│ 5   │ 74    │ 75    │ 76    │ 77    │ 78    │ 79    │ 85     │</code></pre><p>In this example, we have hourly values. We indicated in the  <code>Matrifier</code> to generate a matrix where the size of each row is 6 hours, steps ahead for prediction is 6 hours and the stride of 3 hours. There are 7 columns because the last column indicates the value indicated by the steps <code>ahead</code> argument.</p><p>Let us try to make a matrix with the size of 6 hours, steps ahead of 2 hours, and a stride of 3 hours:</p><pre><code class="language-julia">mtr = Matrifier(Dict(:ahead=&gt;2,:size=&gt;6,:stride=&gt;3))
fit!(mtr,x)
res = transform!(mtr,x)</code></pre><pre><code class="language-julia-repl">julia&gt; first(res,5)
5×7 DataFrames.DataFrame
│ Row │ x1    │ x2    │ x3    │ x4    │ x5    │ x6    │ output │
│     │ Int64 │ Int64 │ Int64 │ Int64 │ Int64 │ Int64 │ Int64  │
├─────┼───────┼───────┼───────┼───────┼───────┼───────┼────────┤
│ 1   │ 90    │ 91    │ 92    │ 93    │ 94    │ 95    │ 97     │
│ 2   │ 87    │ 88    │ 89    │ 90    │ 91    │ 92    │ 94     │
│ 3   │ 84    │ 85    │ 86    │ 87    │ 88    │ 89    │ 91     │
│ 4   │ 81    │ 82    │ 83    │ 84    │ 85    │ 86    │ 88     │
│ 5   │ 78    │ 79    │ 80    │ 81    │ 82    │ 83    │ 85     │</code></pre><footer><hr/><a class="previous" href="../../tutorial/tsclassifier/"><span class="direction">Previous</span><span class="title">TS Data Discovery</span></a><a class="next" href="../dateproc/"><span class="direction">Next</span><span class="title">Date PreProcessing</span></a></footer></article></body></html>
